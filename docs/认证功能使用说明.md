# 认证功能使用说明

## 一、功能说明

本项目已集成JWT认证功能，包括：
- ✅ 全局异常处理
- ✅ 统一日志配置
- ✅ JWT认证拦截器
- ✅ 用户登录/注册接口

## 二、核心组件

### 1. 全局异常处理

**位置**: `contenthub-common/src/main/java/com/contenthub/common/exception/`

**包含类**:
- `BusinessException.java` - 业务异常类
- `GlobalExceptionHandler.java` - 全局异常处理器

**使用示例**:
```java
// 抛出业务异常
throw new BusinessException("用户不存在");
throw new BusinessException(404, "资源未找到");
```

### 2. JWT工具类

**位置**: `contenthub-common/src/main/java/com/contenthub/common/utils/JwtUtils.java`

**主要方法**:
```java
// 生成Token
String token = JwtUtils.generateToken(userId, username);

// 解析Token
Claims claims = JwtUtils.parseToken(token);

// 获取用户ID
Long userId = JwtUtils.getUserIdFromToken(token);

// 获取用户名
String username = JwtUtils.getUsernameFromToken(token);

// 验证Token
boolean isValid = JwtUtils.validateToken(token);

// 刷新Token
String newToken = JwtUtils.refreshToken(token);
```

### 3. JWT拦截器

**位置**: `contenthub-common/src/main/java/com/contenthub/common/interceptor/JwtInterceptor.java`

**功能**:
- 自动拦截所有请求
- 验证Token有效性
- 将用户信息存入请求属性

**排除路径**（不需要认证）:
- `/user/login` - 登录
- `/user/register` - 注册
- `/doc.html` - API文档
- `/actuator/**` - 监控端点

### 4. 统一日志配置

**位置**: `contenthub-common/src/main/resources/logback-spring.xml`

**日志输出**:
- 控制台输出
- 文件输出（按天滚动）
- 错误日志单独记录

**日志路径**: `./logs/`
- `{服务名}.log` - 普通日志
- `{服务名}-error.log` - 错误日志

## 三、用户服务接口

### 1. 用户注册

**接口**: `POST /user/register`

**请求体**:
```json
{
  "username": "testuser",
  "nickname": "测试用户",
  "email": "test@example.com",
  "phone": "13800138000",
  "password": "123456"
}
```

**响应**:
```json
{
  "code": 200,
  "message": "注册成功",
  "data": null,
  "timestamp": 1234567890
}
```

### 2. 用户登录

**接口**: `POST /user/login`

**请求体**:
```json
{
  "username": "testuser",
  "password": "123456"
}
```

**响应**:
```json
{
  "code": 200,
  "message": "操作成功",
  "data": {
    "userId": 1,
    "username": "testuser",
    "nickname": "测试用户",
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "avatarUrl": null
  },
  "timestamp": 1234567890
}
```

### 3. 退出登录

**接口**: `POST /user/logout`

**请求头**: 
```
Authorization: Bearer {token}
```

### 4. 刷新Token

**接口**: `POST /user/refresh`

**请求头**: 
```
Authorization: Bearer {token}
```

### 5. 获取当前用户信息

**接口**: `GET /user/current`

**请求头**: 
```
Authorization: Bearer {token}
```

## 四、在Controller中使用

### 1. 获取当前登录用户

**方式一：从请求属性获取**
```java
@GetMapping("/info")
public Result<?> getUserInfo(HttpServletRequest request) {
    Long userId = (Long) request.getAttribute("userId");
    String username = (String) request.getAttribute("username");
    // 业务逻辑
    return Result.success(data);
}
```

**方式二：使用UserContext**
```java
@GetMapping("/info")
public Result<?> getUserInfo() {
    Long userId = UserContext.getUserId();
    String username = UserContext.getUsername();
    // 业务逻辑
    return Result.success(data);
}
```

### 2. 接口不需要认证

在WebMvcConfig中的excludePathPatterns中添加路径，或使用@NoAuth注解（待实现）。

## 五、配置说明

### 1. JWT密钥配置

在 `JwtUtils.java` 中修改密钥：
```java
private static final String SECRET_KEY = "your-secret-key";
```

### 2. Token有效期

在 `JwtUtils.java` 中修改有效期：
```java
// 7天（单位：毫秒）
private static final long EXPIRATION_TIME = 7 * 24 * 60 * 60 * 1000L;
```

### 3. 拦截器排除路径

在 `WebMvcConfig.java` 中配置：
```java
.excludePathPatterns(
    "/user/login",
    "/user/register",
    // 添加其他不需要认证的路径
)
```

## 六、前端调用示例

### 1. 登录
```javascript
axios.post('/api/user/login', {
  username: 'testuser',
  password: '123456'
}).then(res => {
  // 保存Token到localStorage
  localStorage.setItem('token', res.data.data.token);
});
```

### 2. 请求携带Token
```javascript
axios.get('/api/user/current', {
  headers: {
    'Authorization': 'Bearer ' + localStorage.getItem('token')
  }
}).then(res => {
  console.log(res.data);
});
```

### 3. Axios全局配置
```javascript
// 请求拦截器
axios.interceptors.request.use(config => {
  const token = localStorage.getItem('token');
  if (token) {
    config.headers['Authorization'] = 'Bearer ' + token;
  }
  return config;
});

// 响应拦截器
axios.interceptors.response.use(
  response => response,
  error => {
    if (error.response.status === 401) {
      // Token失效，跳转到登录页
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);
```

## 七、测试

### 1. 使用Postman测试

1. 调用登录接口获取Token
2. 在其他接口的Headers中添加：
   ```
   Key: Authorization
   Value: Bearer {复制的token}
   ```

### 2. 使用Knife4j测试

访问: `http://localhost:8001/doc.html`

1. 调用登录接口获取Token
2. 点击右上角"授权"按钮
3. 输入Token（不需要Bearer前缀）
4. 测试其他需要认证的接口

## 八、注意事项

1. **密码加密**: 使用BCrypt加密，需要在注册时加密，登录时验证
2. **Token安全**: 
   - 不要在URL中传递Token
   - 使用HTTPS传输
   - Token存储在HttpOnly Cookie更安全
3. **异常处理**: 所有业务异常使用BusinessException抛出
4. **日志记录**: 敏感信息不要记录到日志中

## 九、下一步完善

1. 完善UserService的数据库操作逻辑
2. 实现用户实体类和Mapper
3. 集成Redis缓存用户信息
4. 实现密码加密和验证
5. 添加验证码功能
6. 实现Token黑名单机制

